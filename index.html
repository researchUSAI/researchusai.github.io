<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>researchusai.com</title>
  <style>
    body {
      background: #181818;
      color: #BDCEF1;
      font-family: 'Courier New', monospace;
      height: 100vh;
      width: 100vw;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      font-size: 16px;
      line-height: 24px;
      overflow: hidden;
      text-shadow: 
        0 0 5px rgba(189, 206, 241, 0.8),
        0 0 10px rgba(189, 206, 241, 0.5),
        0 0 15px rgba(189, 206, 241, 0.3);
      position: relative;
    }
    /* Scanline overlay */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(
        to bottom,
        rgba(255, 255, 255, 0) 50%,
        rgba(0, 0, 0, 0.1) 50%
      );
      background-size: 100% 4px;
      pointer-events: none;
      z-index: 9999;
      animation: scanline 8s linear infinite;
    }
    @keyframes scanline {
      0% { transform: translateY(0); }
      100% { transform: translateY(4px); }
    }
    @keyframes glow-pulse {
      0%, 100% { 
        box-shadow: 
          0 0 5px rgba(189, 206, 241, 0.4),
          0 0 10px rgba(189, 206, 241, 0.3),
          inset 0 0 5px rgba(189, 206, 241, 0.2);
      }
      50% { 
        box-shadow: 
          0 0 10px rgba(189, 206, 241, 0.6),
          0 0 20px rgba(189, 206, 241, 0.5),
          0 0 30px rgba(189, 206, 241, 0.3),
          inset 0 0 10px rgba(189, 206, 241, 0.3);
      }
    }
    @keyframes border-glow {
      0%, 100% { border-color: #BDCEF1; }
      50% { border-color: #D4E3FF; }
    }
    /* Blinking cursor */
    #input::after {
      content: '█';
      animation: blink 1s step-end infinite;
      color: #BDCEF1;
      text-shadow: 
        0 0 5px rgba(189, 206, 241, 0.8),
        0 0 10px rgba(189, 206, 241, 0.5);
    }
    /* Hide ::after when inline cursor is active */
    #input.has-inline-cursor::after {
      display: none;
    }
    /* Inline cursor for when clicking inside text */
    #inline-cursor {
      position: absolute;
      background: #BDCEF1;
      width: 1ch;
      height: 1em;
      animation: blink 1s step-end infinite;
      pointer-events: none;
      display: none;
      box-shadow: 
        0 0 8px rgba(189, 206, 241, 0.8),
        0 0 15px rgba(189, 206, 241, 0.5);
    }
    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }
    #toolbar {
      flex: 0 0 auto;
      height: var(--toolbar-h, 15vh);
      padding: 0.75em 1ch;
      background: #222;
      border-bottom: 2px solid #BDCEF1;
      display: flex;
      flex-direction: column;
      gap: 0.75em;
      box-shadow: 0 2px 15px rgba(189, 206, 241, 0.3);
      overflow-y: auto;
      overflow-x: hidden;
      box-sizing: border-box;
    }
    #toolbar-row-1,
    #toolbar-row-2 {
      display: flex;
      flex-direction: column;
      gap: 0.75em;
      align-items: stretch;
      width: 100%;
    }
    #toolbar button {
      background: linear-gradient(145deg, #2a2a2a, #3a3a3a);
      color: #BDCEF1;
      border: 2px solid #BDCEF1;
      padding: 1em 1.5em;
      font-family: inherit;
      font-size: 1.1em;
      font-weight: bold;
      cursor: pointer;
      width: 100%;
      min-height: 48px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      text-shadow: 
        0 0 5px rgba(189, 206, 241, 0.8),
        0 0 10px rgba(189, 206, 241, 0.4);
      box-shadow: 
        0 0 8px rgba(189, 206, 241, 0.3),
        inset 0 0 5px rgba(189, 206, 241, 0.1);
      transition: all 0.2s;
      animation: border-glow 2s infinite;
      touch-action: manipulation;
      -webkit-tap-highlight-color: rgba(189, 206, 241, 0.3);
    }
    #toolbar button:hover {
      background: linear-gradient(145deg, #3a3a3a, #4a4a4a);
      box-shadow: 
        0 0 15px rgba(189, 206, 241, 0.5),
        0 0 25px rgba(189, 206, 241, 0.3),
        inset 0 0 8px rgba(189, 206, 241, 0.2);
      transform: translateY(-1px);
    }
    #toolbar button:active {
      background: linear-gradient(145deg, #4a4a4a, #5a5a5a);
      box-shadow: 
        0 0 20px rgba(189, 206, 241, 0.6),
        inset 0 0 12px rgba(189, 206, 241, 0.3);
      transform: translateY(0);
    }
    #polarity-btn {
      background: linear-gradient(145deg, #BDCEF1, #D4E3FF);
      color: #181818;
      font-weight: bold;
      animation: glow-pulse 2s infinite;
    }
    #toxic-btn {
      background: linear-gradient(145deg, #3a3a3a, #4a4a4a);
    }
    #display-container {
      flex: 1 1 auto;
      min-height: 0;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
      border: 2px solid rgba(189, 206, 241, 0.3);
      border-top: none;
      box-shadow: 
        inset 0 0 25px rgba(189, 206, 241, 0.1),
        0 0 15px rgba(189, 206, 241, 0.15);
    }
    #display {
      flex: 0 0 auto;
      height: var(--display-h, 66%);
      min-height: 40px;
      overflow-y: auto;
      padding: 1em 1ch 1em 1ch;
      white-space: pre-wrap;
      word-wrap: break-word;
      font-size: 1.1em;
      line-height: 1.6;
      box-sizing: border-box;
    }
    #input {
      flex: 1 1 auto;
      min-height: 40px;
      border: none;
      border-top: 2px solid rgba(189, 206, 241, 0.3);
      outline: none;
      background: rgba(34, 34, 34, 0.5);
      color: inherit;
      font-family: inherit;
      font-size: 1.1em;
      line-height: 1.6;
      padding: 0.75em 1ch 4em 1ch;
      caret-color: transparent;
      overflow-y: auto;
      overflow-x: hidden;
      white-space: pre-wrap;
      word-wrap: break-word;
      overflow-wrap: break-word;
      word-break: break-word;
      box-sizing: border-box;
    }
    #input::selection {
      background: #BDCEF1;
      color: #181818;
    }
    #input .input-reverse {
      background: #BDCEF1;
      color: #181818;
      padding: 0 0.2ch;
      box-shadow: 
        0 0 8px rgba(189, 206, 241, 0.8),
        0 0 15px rgba(189, 206, 241, 0.5);
    }
    #measure {
      position: absolute;
      visibility: hidden;
      font-family: 'Courier New', monospace;
      white-space: pre;
    }
    .reverse-video {
      background: #BDCEF1;
      color: #181818;
      padding: 0 0.2ch;
      box-shadow: 
        0 0 8px rgba(189, 206, 241, 0.8),
        0 0 15px rgba(189, 206, 241, 0.5);
    }
    .config-value {
      color: #BDCEF1;
      background: #222;
      padding: 0 0.5ch;
      cursor: text;
      white-space: pre-wrap;
      word-wrap: break-word;
      max-width: 50ch;
      display: inline;
      border: 1px solid rgba(189, 206, 241, 0.3);
      box-shadow: 
        0 0 5px rgba(189, 206, 241, 0.2),
        inset 0 0 5px rgba(189, 206, 241, 0.1);
    }
    .message-separator {
      height: 1em;
    }
    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: 12px;
    }
    ::-webkit-scrollbar-track {
      background: #181818;
      border: 1px solid rgba(189, 206, 241, 0.2);
    }
    ::-webkit-scrollbar-thumb {
      background: linear-gradient(145deg, #3a3a3a, #BDCEF1);
      border: 1px solid #BDCEF1;
      box-shadow: 0 0 8px rgba(189, 206, 241, 0.4);
    }
    ::-webkit-scrollbar-thumb:hover {
      background: #BDCEF1;
      box-shadow: 0 0 15px rgba(189, 206, 241, 0.7);
    }
    /* Drag handles */
    .drag-handle {
      flex: 0 0 14px;
      width: 100%;
      background: rgba(189, 206, 241, 0.2);
      border-top: 1px solid rgba(189, 206, 241, 0.5);
      border-bottom: 1px solid rgba(189, 206, 241, 0.5);
      cursor: ns-resize;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      touch-action: none;
      transition: background 0.15s, box-shadow 0.15s;
      z-index: 10;
      position: relative;
    }
    .drag-handle:hover, .drag-handle.dragging {
      background: rgba(189, 206, 241, 0.45);
      box-shadow: 
        0 0 10px rgba(189, 206, 241, 0.5),
        inset 0 0 6px rgba(189, 206, 241, 0.3);
    }
    .drag-handle::after {
      content: '━━━━━';
      color: rgba(189, 206, 241, 0.7);
      font-size: 0.5em;
      letter-spacing: 3px;
      text-shadow: 0 0 6px rgba(189, 206, 241, 0.8);
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <div id="toolbar-row-1">
      <button id="support-btn">Get Code</button>
      <button id="getkey-btn">Get API Key</button>
      <button id="pastecode-btn">Paste Code</button>
      <button id="pastekey-btn">Paste API Key</button>
      <button id="export-btn">Export</button>
      <button id="polarity-btn">Short Form</button>
      <button id="sentence-btn">OFF</button>
      <button id="cta-btn">Call to Action: NO</button>
      <button id="emoji-btn">Emojis: NO</button>
      <button id="toxic-btn">Positive</button>
      <button id="back-btn">Back</button>
      <button id="clear-btn">Clear</button>
      <button id="paste-btn">Paste</button>
    </div>
    <div id="toolbar-row-2">
      <button id="send-btn">Send</button>
      <button id="copy-btn">Copy</button>
    </div>
  </div>
  <div class="drag-handle" id="drag-toolbar"></div>
  <div id="display-container">
    <div id="display"></div>
    <div class="drag-handle" id="drag-display"></div>
    <div id="input" contenteditable="true"></div>
    <div id="inline-cursor"></div>
  </div>
  <span id="measure">M</span>

  <script>
    const State = {
      PROBE_RECOVER: 'probe_recover',
      PROBE_WAIT: 'probe_wait',
      PROBE_RECOVER_RESPONSE: 'probe_recover_response',
      PROBE_RECOVER_CONFIRM: 'probe_recover_confirm',
      PROBE_RECOVER_EDIT: 'probe_recover_edit',
      CALIBRATE_ENDPOINT_RECOVER: 'calibrate_endpoint_recover',
      CALIBRATE_MODEL_RECOVER: 'calibrate_model_recover',
      CALIBRATE_CODE_RECOVER: 'calibrate_code_recover',
      CALIBRATE_KEY_RECOVER: 'calibrate_key_recover',
      CALIBRATE_WAIT: 'calibrate_wait',
    };

    class Structure {
      constructor() {
        this.id = `s_${Date.now()}`;
        this.date = new Date().toLocaleDateString();
        this.day = new Date().toLocaleDateString('en-US', { weekday: 'short' });
        this.releaseTime = null;
        this.log = [];
      }
      addInitiation(probe) {
        this.log.push({ type: 'initiation', id: `i_${Date.now()}`, timestamp: Date.now(), probe });
      }
      addResponse(probe) {
        this.log.push({ type: 'response', id: `r_${Date.now()}`, timestamp: Date.now(), probe });
      }
      release(header) {
        this.releaseTime = new Date().toLocaleTimeString();

        let text = `${this.date} (${this.day})\n`;
        if (this.releaseTime) text += `Released: ${this.releaseTime}\n`;
        text += '\n';

        for (const entry of this.log) {
          const time = new Date(entry.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
          if (entry.type === 'initiation') {
            text += `USER ${time}:\n${entry.probe}\n\n`;
          } else if (entry.type === 'response') {
            // Response already has header built in - use it directly
            text += `LLM ${time}:\n${entry.probe}\n\n`;
          }
        }

        const blob = new Blob([text], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${this.id}.txt`;
        a.click();
        URL.revokeObjectURL(url);
      }
    }

    class Nexus {
      constructor() {
        this.state = State.PROBE_RECOVER;
        this.structures = [];
        this.currentStructure = new Structure();
        this.stack = [];
        this.localBackend = 'https://researchnexus.onrender.com';
        
        // Load from localStorage (browser cache)
        this.modelEndpoint = localStorage.getItem('modelEndpoint') || 'https://api.x.ai';
        this.model = localStorage.getItem('model') || 'grok-4-1-fast-reasoning';
        this.accessCode = localStorage.getItem('accessCode') || '';
        this.apiKey = localStorage.getItem('apiKey') || '';
        this.header = localStorage.getItem('header') || '';
        this.preference = localStorage.getItem('preference') || '';
        this.truth = localStorage.getItem('truth') === 'false' ? false : true;
        this.toxic = localStorage.getItem('toxic') || 'positive'; // New: positive, toxic, formal, humorous
        this.sentenceCount = localStorage.getItem('sentenceCount') || 'off'; // New: off, 1, 2, 3
        this.callToAction = localStorage.getItem('callToAction') === 'true'; // New: true/false
        this.emojis = localStorage.getItem('emojis') === 'true'; // New: true/false
        
        this.dotCount = 0;
        this.dotInterval = null;
        this.display = document.getElementById('display');
        this.input = document.getElementById('input');
        this.inlineCursor = document.getElementById('inline-cursor');
        this.measure = document.getElementById('measure');
        this.backdoorMode = false;
        this.lastInitiation = null;
        this.lastActionWasFileDrop = false;
        this.keyFieldBeingEdited = false;
        this.codeFieldBeingEdited = false;
        this.setupEvents();
        this.setupDragHandles();
        this.updateDimensions();
        
        // Update button text based on loaded state
        this.updateToxicButton();
        this.updatePolarityButton();
        this.updateSentenceButton();
        this.updateCTAButton();
        this.updateEmojiButton();
      }

      setupDragHandles() {
        const toolbar = document.getElementById('toolbar');
        const display = document.getElementById('display');
        const dragToolbar = document.getElementById('drag-toolbar');
        const dragDisplay = document.getElementById('drag-display');

        // Restore saved sizes
        const savedToolbarH = localStorage.getItem('toolbarH');
        const savedDisplayPct = localStorage.getItem('displayPct');
        if (savedToolbarH) toolbar.style.height = savedToolbarH + 'px';
        if (savedDisplayPct) display.style.height = savedDisplayPct + '%';

        const makeDraggable = (handle, onDrag) => {
          let startY = 0;
          let dragging = false;

          const start = (y) => {
            startY = y;
            dragging = true;
            handle.classList.add('dragging');
            document.body.style.userSelect = 'none';
          };

          const move = (y) => {
            if (!dragging) return;
            const delta = y - startY;
            startY = y;
            onDrag(delta);
          };

          const end = () => {
            dragging = false;
            handle.classList.remove('dragging');
            document.body.style.userSelect = '';
          };

          // Mouse
          handle.addEventListener('mousedown', (e) => { e.preventDefault(); start(e.clientY); });
          document.addEventListener('mousemove', (e) => move(e.clientY));
          document.addEventListener('mouseup', end);

          // Touch
          handle.addEventListener('touchstart', (e) => { e.preventDefault(); start(e.touches[0].clientY); }, { passive: false });
          document.addEventListener('touchmove', (e) => { if (dragging) { e.preventDefault(); move(e.touches[0].clientY); } }, { passive: false });
          document.addEventListener('touchend', end);
        };

        // Handle 1: resize toolbar
        makeDraggable(dragToolbar, (delta) => {
          const current = toolbar.getBoundingClientRect().height;
          const newH = Math.max(40, Math.min(window.innerHeight * 0.6, current + delta));
          toolbar.style.height = newH + 'px';
          localStorage.setItem('toolbarH', Math.round(newH));
        });

        // Handle 2: resize display vs input
        makeDraggable(dragDisplay, (delta) => {
          const container = document.getElementById('display-container');
          const containerH = container.getBoundingClientRect().height;
          const currentH = display.getBoundingClientRect().height;
          const newH = Math.max(40, Math.min(containerH - 80, currentH + delta));
          const pct = (newH / containerH) * 100;
          display.style.height = pct + '%';
          localStorage.setItem('displayPct', pct.toFixed(2));
        });
      }

      setupEvents() {
        window.addEventListener('resize', () => this.updateDimensions());

        this.input.addEventListener('input', () => {
          this.normalizeInput();
        });

        this.input.addEventListener('click', () => {
          this.updateInlineCursor();
        });

        this.input.addEventListener('keyup', () => {
          this.updateInlineCursor();
        });

        this.input.addEventListener('focus', () => {
          this.updateInlineCursor();
        });

        this.input.addEventListener('blur', () => {
          this.inlineCursor.style.display = 'none';
        });

        this.input.addEventListener('paste', (e) => {
          e.preventDefault();
          const text = (e.clipboardData || window.clipboardData).getData('text/plain');
          if (text) {
            // Use execCommand to insert text - this triggers input event which calls normalizeInput
            document.execCommand('insertText', false, text);
          }
        });

        document.addEventListener('selectionchange', () => {
          if (document.activeElement === this.input) {
            this.updateInlineCursor();
          }
        });

        document.addEventListener('keydown', async (e) => {
          if (e.key === 'Enter' && e.shiftKey) {
            e.preventDefault();
            document.execCommand('insertText', false, ' '.repeat(50));
          } else if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            const cmd = this.input.textContent.trim();
            this.input.innerHTML = '';
            if (cmd) await this.process(cmd);
          } else if ((e.metaKey || e.ctrlKey) && (e.key === 'c' || e.key === 'C')) {
            // Let browser handle copy normally
            return;
          } else if ((e.metaKey || e.ctrlKey) && (e.key === 'v' || e.key === 'V')) {
            // Let browser handle paste normally
            return;
          } else if ((e.metaKey || e.ctrlKey) && (e.key === 'x' || e.key === 'X')) {
            // Let browser handle cut normally
            return;
          } else if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
            return;
          } else {
            return;
          }
        });

        document.getElementById('export-btn').addEventListener('click', () => {
          const btn = document.getElementById('export-btn');
          if (this.currentStructure) {
            this.currentStructure.release(this.header);
            btn.textContent = 'Exported!';
            setTimeout(() => {
              btn.textContent = 'Export';
            }, 1000);
          }
        });

        document.getElementById('back-btn').addEventListener('click', () => {
          if (this.lastActionWasFileDrop && this.structures.length > 0) {
            this.structures.pop();
            this.lastActionWasFileDrop = false;
            this.state = State.PROBE_RECOVER;
            this.render();
            this.scrollToBottom();
          } else if (this.state === State.PROBE_RECOVER_EDIT && this.stack.length > 0) {
            // Already in edit mode, go back one more level
            if (confirm('Go back and edit an earlier message?')) {
              if (this.stack.length > 0 && this.currentStructure.log.length > 0) {
                if (this.stack[this.stack.length - 1].startsWith('llm:\n')) {
                  this.stack.pop();
                }
                if (this.currentStructure.log[this.currentStructure.log.length - 1].type === 'response') {
                  this.currentStructure.log.pop();
                }
                if (this.stack.length > 0 && this.stack[this.stack.length - 1].startsWith('user:\n')) {
                  this.lastInitiation = this.stack[this.stack.length - 1].slice('user:\n'.length);
                  this.stack.pop();
                } else {
                  this.lastInitiation = '';
                }
                if (this.currentStructure.log.length > 0 && this.currentStructure.log[this.currentStructure.log.length - 1].type === 'initiation') {
                  this.currentStructure.log.pop();
                }
                this.state = State.PROBE_RECOVER_EDIT;
              }
              this.render();
              this.scrollToBottom();
            }
          } else if (this.stack.length > 0) {
            // Normal case - first time going back
            if (confirm('Go back and edit the last message?')) {
              // Yes - go back
              if (this.stack.length > 0 && this.currentStructure.log.length > 0) {
                if (this.stack[this.stack.length - 1].startsWith('llm:\n')) {
                  this.stack.pop();
                }
                if (this.currentStructure.log[this.currentStructure.log.length - 1].type === 'response') {
                  this.currentStructure.log.pop();
                }
                if (this.stack.length > 0 && this.stack[this.stack.length - 1].startsWith('user:\n')) {
                  this.lastInitiation = this.stack[this.stack.length - 1].slice('user:\n'.length);
                  this.stack.pop();
                } else {
                  this.lastInitiation = '';
                }
                if (this.currentStructure.log.length > 0 && this.currentStructure.log[this.currentStructure.log.length - 1].type === 'initiation') {
                  this.currentStructure.log.pop();
                }
                this.state = State.PROBE_RECOVER_EDIT;
              } else {
                this.lastInitiation = '';
                this.state = State.PROBE_RECOVER;
              }
            } else {
              // No - cancel
              this.lastInitiation = null;
              this.state = State.PROBE_RECOVER;
            }
            this.render();
            this.scrollToBottom();
          }
        });

        document.getElementById('toxic-btn').addEventListener('click', () => {
          // Cycle through: positive -> toxic -> formal -> humorous -> positive
          const modes = ['positive', 'toxic', 'formal', 'humorous'];
          const currentIndex = modes.indexOf(this.toxic);
          this.toxic = modes[(currentIndex + 1) % modes.length];
          this.updateToxicButton();
          localStorage.setItem('toxic', this.toxic);
        });

        document.getElementById('polarity-btn').addEventListener('click', () => {
          this.truth = !this.truth;
          this.updatePolarityButton();
          localStorage.setItem('truth', this.truth.toString());
          this.render();
        });

        document.getElementById('sentence-btn').addEventListener('click', () => {
          // Cycle through: off -> 1 -> 2 -> 3 -> off
          const counts = ['off', '1', '2', '3'];
          const currentIndex = counts.indexOf(this.sentenceCount);
          this.sentenceCount = counts[(currentIndex + 1) % counts.length];
          this.updateSentenceButton();
          localStorage.setItem('sentenceCount', this.sentenceCount);
        });

        document.getElementById('cta-btn').addEventListener('click', () => {
          this.callToAction = !this.callToAction;
          this.updateCTAButton();
          localStorage.setItem('callToAction', this.callToAction.toString());
        });

        document.getElementById('emoji-btn').addEventListener('click', () => {
          this.emojis = !this.emojis;
          this.updateEmojiButton();
          localStorage.setItem('emojis', this.emojis.toString());
        });

        document.getElementById('clear-btn').addEventListener('click', () => {
          const btn = document.getElementById('clear-btn');
          this.input.innerHTML = '';
          this.input.focus();
          btn.textContent = 'Cleared!';
          setTimeout(() => {
            btn.textContent = 'Clear';
          }, 1000);
        });

        document.getElementById('paste-btn').addEventListener('click', async () => {
          const btn = document.getElementById('paste-btn');
          
          // Prevent multiple clicks
          if (btn.textContent === 'Pasted!') return;
          
          try {
            const text = await navigator.clipboard.readText();
            if (text) {
              // Focus input and use execCommand to paste - triggers normalizeInput naturally
              this.input.focus();
              document.execCommand('insertText', false, text);
              
              btn.textContent = 'Pasted!';
              setTimeout(() => {
                btn.textContent = 'Paste';
              }, 1000);
            }
          } catch (err) {
            // Fallback for browsers that don't support clipboard API or if permission denied
            alert('Paste failed. Try using Ctrl+V / Cmd+V instead.');
          }
        });

        document.getElementById('send-btn').addEventListener('click', async () => {
          const btn = document.getElementById('send-btn');
          const content = this.input.textContent.trim();
          if (content) {
            this.input.innerHTML = '';
            btn.textContent = 'Sent!';
            setTimeout(() => {
              btn.textContent = 'Send';
            }, 1000);
            await this.process(content);
          }
        });

        document.getElementById('copy-btn').addEventListener('click', () => {
          const btn = document.getElementById('copy-btn');
          
          // Prevent multiple clicks
          if (btn.textContent === 'Copied!') return;
          
          // Find the most recent LLM response in the stack
          let lastResponse = '';
          for (let i = this.stack.length - 1; i >= 0; i--) {
            if (this.stack[i].startsWith('llm:\n')) {
              lastResponse = this.stack[i].slice('llm:\n'.length);
              break;
            }
          }
          
          if (lastResponse) {
            // Use old-school copy method that works over HTTP
            const textArea = document.createElement('textarea');
            textArea.value = lastResponse;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.select();
            
            try {
              document.execCommand('copy');
              document.body.removeChild(textArea);
              btn.textContent = 'Copied!';
              setTimeout(() => {
                btn.textContent = 'Copy';
              }, 1000);
            } catch (err) {
              document.body.removeChild(textArea);
              alert('Failed to copy: ' + err.message);
            }
          } else {
            alert('No response to copy');
          }
        });

        document.getElementById('support-btn').addEventListener('click', () => {
          window.open('https://ko-fi.com/s/c95d095bc5', '_blank');
        });

        document.getElementById('getkey-btn').addEventListener('click', () => {
          window.open('https://console.x.ai/team/4e4cc61f-c596-41c2-91ab-78a1258ac206', '_blank');
        });

        document.getElementById('pastecode-btn').addEventListener('click', async () => {
          const btn = document.getElementById('pastecode-btn');
          if (btn.textContent === 'Pasted!') return;
          try {
            const text = await navigator.clipboard.readText();
            if (text) {
              const trimmedCode = text.trim();
              if (trimmedCode) {
                this.accessCode = trimmedCode;
                localStorage.setItem('accessCode', this.accessCode);
                const codeEl = document.getElementById('edit-code');
                if (codeEl) {
                  codeEl.textContent = trimmedCode;
                  codeEl.setAttribute('data-actual-code', trimmedCode);
                }
                this.render(); // Re-render to apply masking
                btn.textContent = 'Pasted!';
                setTimeout(() => { btn.textContent = 'Paste Code'; }, 1000);
              }
            }
          } catch (err) {
            alert('Paste failed. Please copy your access code first, then try again.');
          }
        });

        document.getElementById('pastekey-btn').addEventListener('click', async () => {
          const btn = document.getElementById('pastekey-btn');
          
          // Prevent multiple clicks
          if (btn.textContent === 'Pasted!') return;
          
          try {
            const text = await navigator.clipboard.readText();
            if (text) {
              const trimmedKey = text.trim();
              if (trimmedKey) {
                // Save the key directly
                this.apiKey = trimmedKey;
                localStorage.setItem('apiKey', this.apiKey);
                
                // Update the key field in the DOM
                const keyEl = document.getElementById('edit-key');
                if (keyEl) {
                  keyEl.textContent = trimmedKey;
                  keyEl.setAttribute('data-actual-key', trimmedKey);
                }
                this.render(); // Re-render to apply masking
                btn.textContent = 'Pasted!';
                setTimeout(() => {
                  btn.textContent = 'Paste API Key';
                }, 1000);
              }
            }
          } catch (err) {
            alert('Paste failed. Please copy your API key first, then try again.');
          }
        });

        this.display.addEventListener('focus', (e) => {
          if (e.target.id === 'edit-key') {
            this.keyFieldBeingEdited = true;
            const keyText = e.target.textContent.trim();
            const actualKey = e.target.getAttribute('data-actual-key');
            if (keyText.match(/^•+$/) && actualKey) {
              e.target.textContent = actualKey;
            }
            const range = document.createRange();
            range.selectNodeContents(e.target);
            range.collapse(false);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
          } else if (e.target.id === 'edit-code') {
            this.codeFieldBeingEdited = true;
            const codeText = e.target.textContent.trim();
            const actualCode = e.target.getAttribute('data-actual-code');
            if (codeText.match(/^•+$/) && actualCode) {
              e.target.textContent = actualCode;
            }
            const range = document.createRange();
            range.selectNodeContents(e.target);
            range.collapse(false);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
          }
        }, true);

        this.display.addEventListener('blur', (e) => {
          if (e.target.id === 'edit-key') {
            this.keyFieldBeingEdited = false;
            this.render();
          } else if (e.target.id === 'edit-code') {
            this.codeFieldBeingEdited = false;
            this.render();
          }
        }, true);
      }

      updateToxicButton() {
        const btn = document.getElementById('toxic-btn');
        const labels = {
          'positive': 'Positive',
          'toxic': 'Toxic',
          'formal': 'Formal',
          'humorous': 'Humorous'
        };
        btn.textContent = labels[this.toxic] || 'Positive';
      }

      updatePolarityButton() {
        const btn = document.getElementById('polarity-btn');
        btn.textContent = this.truth ? 'Short Form' : 'Long Form';
      }

      updateSentenceButton() {
        const btn = document.getElementById('sentence-btn');
        if (this.sentenceCount === 'off') {
          btn.textContent = 'OFF';
        } else {
          btn.textContent = this.sentenceCount + ' Sentence' + (this.sentenceCount === '1' ? '' : 's');
        }
      }

      updateCTAButton() {
        const btn = document.getElementById('cta-btn');
        btn.textContent = 'Call to Action: ' + (this.callToAction ? 'YES' : 'NO');
      }

      updateEmojiButton() {
        const btn = document.getElementById('emoji-btn');
        btn.textContent = 'Emojis: ' + (this.emojis ? 'YES' : 'NO');
      }

      normalizeInput() {
        const selection = window.getSelection();
        let cursorOffset = 0;

        if (selection.rangeCount > 0) {
          const range = selection.getRangeAt(0);
          const preCaretRange = range.cloneRange();
          preCaretRange.selectNodeContents(this.input);
          preCaretRange.setEnd(range.endContainer, range.endOffset);
          cursorOffset = preCaretRange.toString().length;
        }

        const textContent = this.input.textContent;

        this.input.innerHTML = '';
        if (textContent) {
          const span = document.createElement('span');
          span.className = 'input-reverse';
          span.textContent = textContent;
          this.input.appendChild(span);

          try {
            const range = document.createRange();
            const textNode = span.firstChild;
            if (textNode) {
              const offset = Math.min(cursorOffset, textNode.length);
              range.setStart(textNode, offset);
              range.collapse(true);
              selection.removeAllRanges();
              selection.addRange(range);
            }
          } catch (e) {
            const range = document.createRange();
            range.selectNodeContents(this.input);
            range.collapse(false);
            selection.removeAllRanges();
            selection.addRange(range);
          }
        }
        // Removed scrollToBottom - don't scroll display during typing
      }

      updateDimensions() {
        this.measure.style.fontSize = '100px';
        const measuredWidth = this.measure.offsetWidth;
        const pixelsPerChar = measuredWidth / 1;
        const targetWidth = window.innerWidth;
        const newFontSize = (targetWidth / 50) * (100 / pixelsPerChar);
        const newLineHeight = window.innerHeight / 24;
        document.body.style.fontSize = `${newFontSize}px`;
        document.body.style.lineHeight = `${newLineHeight}px`;
        
        // Update cursor position after font size change
        setTimeout(() => this.updateInlineCursor(), 0);
      }

      startWait() {
        this.dotCount = 0;
        if (this.dotInterval) clearInterval(this.dotInterval);
        this.dotInterval = setInterval(() => {
          this.dotCount = (this.dotCount + 1) % 4;
          this.render();
        }, 1000);
      }

      stopWait() {
        if (this.dotInterval) {
          clearInterval(this.dotInterval);
          this.dotInterval = null;
        }
        this.dotCount = 0;
      }

      scrollToBottom() {
        this.display.scrollTop = this.display.scrollHeight;
      }

      updateInlineCursor() {
        const sel = window.getSelection();
        if (!sel.rangeCount || document.activeElement !== this.input) {
          this.inlineCursor.style.display = 'none';
          this.input.classList.remove('has-inline-cursor');
          return;
        }

        const range = sel.getRangeAt(0);
        if (!range.collapsed) {
          // Text is selected, hide cursor
          this.inlineCursor.style.display = 'none';
          this.input.classList.remove('has-inline-cursor');
          return;
        }

        // Get cursor position in text
        const preCaretRange = range.cloneRange();
        preCaretRange.selectNodeContents(this.input);
        preCaretRange.setEnd(range.endContainer, range.endOffset);
        const caretOffset = preCaretRange.toString().length;
        const totalLength = this.input.textContent.length;
        
        // Check if at the very end
        if (caretOffset === totalLength) {
          // At end - ::after will show, hide inline cursor
          this.inlineCursor.style.display = 'none';
          this.input.classList.remove('has-inline-cursor');
          return;
        }

        // Not at end - show inline cursor at exact position, hide ::after
        const rect = range.getBoundingClientRect();
        const containerRect = document.getElementById('display-container').getBoundingClientRect();
        
        // Adjust vertical position - move cursor down slightly to align with text baseline
        const computedStyle = getComputedStyle(this.input);
        const fontSize = parseFloat(computedStyle.fontSize);
        const lineHeight = parseFloat(computedStyle.lineHeight);
        const adjustment = (lineHeight - fontSize) / 4;
        
        this.inlineCursor.style.display = 'block';
        this.input.classList.add('has-inline-cursor');
        this.inlineCursor.style.left = `${rect.left - containerRect.left}px`;
        this.inlineCursor.style.top = `${rect.top - containerRect.top + adjustment}px`;
      }

      formatStructures() {
        if (this.structures.length === 0) return '';
        return this.structures.map((s, i) => {
          const preview = s.log.length > 0 ? s.log[0].probe.substring(0, 20) : 'empty';
          return `[${i}]: [${s.date}] [${s.day}] [${s.releaseTime || 'active'}] [${preview}...]`;
        }).join('\n');
      }

      formatStack() {
        return this.stack.map(line => {
          if (line.startsWith('user:\n')) {
            const probe = line.slice('user:\n'.length);
            return '<span class="reverse-video">post:</span>\n' + probe + '<div class="message-separator"></div>';
          } else if (line.startsWith('llm:\n')) {
            const response = line.slice('llm:\n'.length);
            // Response already has header built in - don't add it again
            return '<span class="reverse-video">reply:</span>\n' + response + '<div class="message-separator"></div>';
          }
          return line;
        }).join('');
      }

      async validateCode() {
        const FAMILY_CODE = 'researchthefuture0612';
        if (this.accessCode === FAMILY_CODE) return true;
        if (!this.accessCode || this.accessCode === 'NULL') {
          alert('Please enter your access code in the code: field.\nPurchase a code at ko-fi.com/researchkofi');
          return false;
        }
        try {
          const response = await fetch(`${this.localBackend}/validate_code?code=${encodeURIComponent(this.accessCode)}`);
          if (!response.ok) {
            alert('Could not validate access code. Server error. Try again.');
            return false;
          }
          const data = await response.json();
          if (!data.valid) {
            alert(data.message || 'Invalid or expired code.\nPurchase a new code at ko-fi.com/researchkofi');
            return false;
          }
          // Warn when 5 or fewer days remain (skip for family code)
          if (data.days_left !== 9999 && data.days_left <= 5) {
            alert(`Your access code expires in ${data.days_left} day(s).\nPurchase a new code soon at ko-fi.com/researchkofi`);
          }
          return true;
        } catch (e) {
          // Network failure - fail open so users aren't locked out by a server hiccup
          console.warn('Code validation network error:', e);
          return true;
        }
      }

      async coordinate(probe) {
        // Validate access code before every request
        const isValid = await this.validateCode();
        if (!isValid) {
          // Pop the user entry that was already pushed before this call
          if (this.stack.length > 0 && this.stack[this.stack.length - 1] === `user:\n${probe}`) {
            this.stack.pop();
          }
          if (this.currentStructure.log.length > 0 && this.currentStructure.log[this.currentStructure.log.length - 1].type === 'initiation') {
            this.currentStructure.log.pop();
          }
          this.state = State.PROBE_RECOVER;
          this.stopWait();
          this.render();
          return null;
        }

        let fullProbe = '';
        if (this.structures.length > 0) {
          for (const structure of this.structures) {
            for (const entry of structure.log) {
              if (entry.type === 'initiation') {
                fullProbe += `user:\n${entry.probe}\n`;
              } else if (entry.type === 'response') {
                fullProbe += `llm:\n${entry.probe}\n`;
              }
            }
          }
        }
        
        if (this.stack.length > 0) {
          fullProbe += this.stack.join('');
        }
        
        fullProbe += probe;
        
        try {
          const response = await fetch(`${this.localBackend}/generate_prompt`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              probe: fullProbe,
              truth: this.truth,
              toxic: this.toxic,
              sentence_count: this.sentenceCount,
              call_to_action: this.callToAction,
              emojis: this.emojis,
              preference: this.preference,
              base_url: this.modelEndpoint,
              api_key: this.apiKey,
              model: this.model
            })
          });

          if (!response.ok) {
            const err = await response.json();
            return `[ERROR: ${err.error || 'Backend failed'}]`;
          }

          const reader = response.body.getReader();
          let hasAddedHeader = false;

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = new TextDecoder().decode(value);
            
            if (!hasAddedHeader) {
              // First chunk - prepend header once
              const firstContent = this.header ? this.header + chunk : chunk;
              this.stack.push(`llm:\n${firstContent}`);
              hasAddedHeader = true;
            } else {
              // Subsequent chunks - just append (no header)
              this.stack[this.stack.length - 1] += chunk;
            }

            this.render();
            this.scrollToBottom(); // Scroll display during streaming
          }

          // Extract complete response (with header) from stack
          const completeResponse = this.stack[this.stack.length - 1].slice('llm:\n'.length);
          this.currentStructure.addResponse(completeResponse);

          return completeResponse;
        } catch (e) {
          return `[ERROR: ${e.message || 'Network failure'}]`;
        }
      }

      render() {
        const endpointEl = document.getElementById('edit-endpoint');
        const modelEl = document.getElementById('edit-model');
        const codeEl = document.getElementById('edit-code');
        const keyEl = document.getElementById('edit-key');
        const headerEl = document.getElementById('edit-header');
        const preferenceEl = document.getElementById('edit-preference');
        
        // Preserve current values from DOM if they exist
        let currentEndpoint = this.modelEndpoint;
        let currentModel = this.model;
        let currentCodeDisplay = '';
        let currentKeyDisplay = '';
        let currentHeader = this.header;
        let currentPreference = this.preference;
        
        if (endpointEl && endpointEl.textContent.trim() !== 'NULL') {
          currentEndpoint = endpointEl.textContent.trim();
          this.modelEndpoint = currentEndpoint;
          localStorage.setItem('modelEndpoint', this.modelEndpoint);
        }
        if (modelEl && modelEl.textContent.trim() !== 'NULL') {
          currentModel = modelEl.textContent.trim();
          this.model = currentModel;
          localStorage.setItem('model', this.model);
        }
        if (codeEl && !this.codeFieldBeingEdited) {
          const codeText = codeEl.textContent.trim();
          // Only update accessCode if it's NOT bullets (meaning user edited it)
          if (!codeText.match(/^•+$/) && codeText !== 'NULL' && codeText !== '') {
            this.accessCode = codeText;
            localStorage.setItem('accessCode', this.accessCode);
          }
          // Show masked code or NULL
          currentCodeDisplay = (this.accessCode && this.accessCode !== 'NULL' && this.accessCode !== '') ? '•'.repeat(this.accessCode.length) : 'NULL';
        } else if (codeEl) {
          // Keep whatever is currently displayed while editing
          currentCodeDisplay = codeEl.textContent;
        } else {
          // First render
          currentCodeDisplay = (this.accessCode && this.accessCode !== 'NULL' && this.accessCode !== '') ? '•'.repeat(this.accessCode.length) : 'NULL';
        }
        
        if (keyEl && !this.keyFieldBeingEdited) {
          const keyText = keyEl.textContent.trim();
          // Only update apiKey if it's NOT bullets (meaning user edited it)
          if (!keyText.match(/^•+$/) && keyText !== 'NULL' && keyText !== '') {
            this.apiKey = keyText;
            localStorage.setItem('apiKey', this.apiKey);
          }
          // Show masked key or NULL
          currentKeyDisplay = (this.apiKey && this.apiKey !== 'NULL' && this.apiKey !== '') ? '•'.repeat(this.apiKey.length) : 'NULL';
        } else if (keyEl) {
          // Keep whatever is currently displayed while editing
          currentKeyDisplay = keyEl.textContent;
        } else {
          // First render
          currentKeyDisplay = (this.apiKey && this.apiKey !== 'NULL' && this.apiKey !== '') ? '•'.repeat(this.apiKey.length) : 'NULL';
        }
        
        if (headerEl) {
          const headerText = headerEl.textContent;
          if (headerText !== 'NULL' && headerText !== '') {
            currentHeader = headerText;
            this.header = currentHeader;
            localStorage.setItem('header', this.header);
          }
        }
        if (preferenceEl && preferenceEl.textContent.trim() !== 'NULL') {
          currentPreference = preferenceEl.textContent.trim();
          this.preference = currentPreference;
          localStorage.setItem('preference', this.preference);
        }

        let output = '';
        const structures = this.formatStructures();
        let blockInput = false;

        output += '<span class="reverse-video">code:</span> <span id="edit-code" class="config-value" contenteditable="true" data-actual-code="' + (this.accessCode || '') + '">' + currentCodeDisplay + '</span>\n';
        output += '<span class="reverse-video">endpoint:</span> <span id="edit-endpoint" class="config-value" contenteditable="true">' + (currentEndpoint || 'https://api.x.ai') + '</span>\n';
        output += '<span class="reverse-video">model:</span> <span id="edit-model" class="config-value" contenteditable="true">' + (currentModel || 'grok-4-1-fast-reasoning') + '</span>\n';
        output += '<span class="reverse-video">api key:</span> <span id="edit-key" class="config-value" contenteditable="true" data-actual-key="' + (this.apiKey || '') + '">' + currentKeyDisplay + '</span>\n';
        const headerDisplay = currentHeader || 'NULL';
        const headerAttr = (currentHeader || '').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
        output += '<span class="reverse-video">header:</span> <span id="edit-header" class="config-value" contenteditable="true" data-raw-header="' + headerAttr + '">' + headerDisplay + '</span>\n';
        output += '<span class="reverse-video">preference:</span> <span id="edit-preference" class="config-value" contenteditable="true">' + (currentPreference || 'NULL') + '</span>\n';
        output += '<div class="message-separator"></div>';

        switch(this.state) {
          case State.PROBE_RECOVER:
          case State.PROBE_RECOVER_RESPONSE:
            if (structures) output += structures + '\n';
            if (this.stack.length > 0) output += this.formatStack();
            break;
          case State.PROBE_WAIT:
            if (structures) output += structures + '\n';
            if (this.stack.length > 0) {
              output += this.formatStack();
            } else {
              output += '<span class="reverse-video">post:' + (this.currentProbe ? '\n' + this.currentProbe : '') + '</span><div class="message-separator"></div>';
            }
            blockInput = true;
            break;
          case State.PROBE_RECOVER_EDIT:
            if (structures) output += structures + '\n';
            if (this.stack.length > 0) output += this.formatStack();
            break;
          case State.CALIBRATE_ENDPOINT_RECOVER:
            output += '/route\n<span class="reverse-video">endpoint: ' + (this.modelEndpoint || 'https://api.x.ai') + '</span>';
            break;
          case State.CALIBRATE_MODEL_RECOVER:
            output += '/route\n<span class="reverse-video">model: ' + (this.model || 'grok-4-1-fast-reasoning') + '</span>';
            break;
          case State.CALIBRATE_KEY_RECOVER:
            output += '/route\n<span class="reverse-video">api key: ' + (this.apiKey || 'NULL') + '</span>';
            break;
          case State.CALIBRATE_WAIT:
            output += 'processing...';
            blockInput = true;
            break;
        }

        this.display.innerHTML = output;
        
        // Set masked code text content after HTML is rendered to preserve whitespace
        if (!this.codeFieldBeingEdited) {
          const codeElAfterRender = document.getElementById('edit-code');
          if (codeElAfterRender) {
            const maskedCode = (this.accessCode && this.accessCode !== 'NULL') ? '•'.repeat(this.accessCode.length) : 'NULL';
            codeElAfterRender.textContent = maskedCode;
          }
        }
        
        // Set masked key text content after HTML is rendered to preserve whitespace
        if (!this.keyFieldBeingEdited) {
          const keyElAfterRender = document.getElementById('edit-key');
          if (keyElAfterRender) {
            const maskedKey = (this.apiKey && this.apiKey !== 'NULL') ? '•'.repeat(this.apiKey.length) : 'NULL';
            keyElAfterRender.textContent = maskedKey;
          }
        }
        
        this.input.contentEditable = !blockInput;
        if (!blockInput) {
          // If in edit mode, populate with lastInitiation in reverse video
          if (this.state === State.PROBE_RECOVER_EDIT && this.lastInitiation) {
            const span = document.createElement('span');
            span.className = 'input-reverse';
            span.textContent = this.lastInitiation;
            this.input.innerHTML = '';
            this.input.appendChild(span);
          } else {
            this.input.textContent = '';
          }
          // Removed auto-scroll - only scroll during LLM streaming
        } else {
          // Don't auto-scroll here either
        }
      }

      async process(cmd) {
        const cmdLower = cmd.toLowerCase();

        switch(this.state) {
          case State.PROBE_RECOVER:
          case State.PROBE_RECOVER_RESPONSE:
            if (cmdLower === '/release') {
              if (this.currentStructure) {
                this.currentStructure.release(this.header);
                return;
              }
            } else if (cmdLower === '/recover') {
              if (this.lastActionWasFileDrop && this.structures.length > 0) {
                this.structures.pop();
                this.lastActionWasFileDrop = false;
                this.state = State.PROBE_RECOVER;
              } else if (this.stack.length > 0) {
                // Show confirm dialog
                if (confirm('Go back and edit the last message?')) {
                  // Yes - go back
                  if (this.stack.length > 0 && this.currentStructure.log.length > 0) {
                    if (this.stack[this.stack.length - 1].startsWith('llm:\n')) {
                      this.stack.pop();
                    }
                    if (this.currentStructure.log[this.currentStructure.log.length - 1].type === 'response') {
                      this.currentStructure.log.pop();
                    }
                    if (this.stack.length > 0 && this.stack[this.stack.length - 1].startsWith('user:\n')) {
                      this.lastInitiation = this.stack[this.stack.length - 1].slice('user:\n'.length);
                      this.stack.pop();
                    } else {
                      this.lastInitiation = '';
                    }
                    if (this.currentStructure.log.length > 0 && this.currentStructure.log[this.currentStructure.log.length - 1].type === 'initiation') {
                      this.currentStructure.log.pop();
                    }
                    this.state = State.PROBE_RECOVER_EDIT;
                  } else {
                    this.lastInitiation = '';
                    this.state = State.PROBE_RECOVER;
                  }
                } else {
                  // No - cancel
                  this.lastInitiation = null;
                  this.state = State.PROBE_RECOVER;
                }
              }
            } else if (cmdLower === '/polarity') {
              this.truth = !this.truth;
              document.getElementById('polarity-btn').textContent = this.truth ? 'Short Response' : 'Long Response';
              localStorage.setItem('truth', this.truth.toString());
              this.state = State.PROBE_RECOVER;
            } else if (cmdLower === '/endpoint') {
              this.state = State.CALIBRATE_ENDPOINT_RECOVER;
            } else if (cmdLower === '/model') {
              this.state = State.CALIBRATE_MODEL_RECOVER;
            } else if (cmdLower === '/key') {
              this.state = State.CALIBRATE_KEY_RECOVER;
            } else if (cmdLower.startsWith('/')) {
              return;
            } else {
              this.stack.push(`user:\n${cmd}`);
              this.currentStructure.addInitiation(cmd);
              this.lastActionWasFileDrop = false;
              this.state = State.PROBE_WAIT;
              this.render();
              this.scrollToBottom();
              this.startWait();
              this.currentProbe = cmd;
              const response = await this.coordinate(cmd);
              this.stopWait();
              if (response === null) break; // validation failed, state already reset
              this.state = State.PROBE_RECOVER_RESPONSE;
              this.lastInitiation = null;
            }
            break;

          case State.PROBE_RECOVER_EDIT:
            if (cmdLower === '/release') {
              if (this.currentStructure) {
                this.currentStructure.release(this.header);
                this.lastInitiation = null;
                return;
              }
            } else if (cmdLower === '/recover') {
              this.lastInitiation = null;
              this.state = State.PROBE_RECOVER;
            } else if (cmdLower === '/polarity') {
              this.truth = !this.truth;
              document.getElementById('polarity-btn').textContent = this.truth ? 'Short Response' : 'Long Response';
              localStorage.setItem('truth', this.truth.toString());
              this.lastInitiation = null;
              this.state = State.PROBE_RECOVER;
            } else if (cmdLower === '/endpoint') {
              this.lastInitiation = null;
              this.state = State.CALIBRATE_ENDPOINT_RECOVER;
            } else if (cmdLower === '/model') {
              this.lastInitiation = null;
              this.state = State.CALIBRATE_MODEL_RECOVER;
            } else if (cmdLower === '/key') {
              this.lastInitiation = null;
              this.state = State.CALIBRATE_KEY_RECOVER;
            } else if (cmdLower.startsWith('/')) {
              return;
            } else {
              if (cmd) {
                this.stack.push(`user:\n${cmd}`);
                this.currentStructure.addInitiation(cmd);
              }
              this.lastActionWasFileDrop = false;
              this.state = State.PROBE_WAIT;
              this.render();
              this.scrollToBottom();
              this.startWait();
              this.currentProbe = cmd;
              const response = await this.coordinate(cmd);
              this.stopWait();
              if (response === null) break; // validation failed, state already reset
              this.state = State.PROBE_RECOVER_RESPONSE;
              this.lastInitiation = null;
            }
            break;

          case State.CALIBRATE_ENDPOINT_RECOVER:
            if (cmdLower === '/route') {
              this.state = State.PROBE_RECOVER;
            } else {
              this.modelEndpoint = cmd;
              this.backdoorMode = (cmd === 'backdoor');
              this.state = State.CALIBRATE_WAIT;
              setTimeout(() => {
                this.stopWait();
                this.state = State.PROBE_RECOVER;
                this.render();
              }, 3000);
            }
            break;

          case State.CALIBRATE_MODEL_RECOVER:
            if (cmdLower === '/route') {
              this.state = State.PROBE_RECOVER;
            } else {
              this.model = cmd;
              this.state = State.CALIBRATE_WAIT;
              setTimeout(() => {
                this.stopWait();
                this.state = State.PROBE_RECOVER;
                this.render();
              }, 3000);
            }
            break;

          case State.CALIBRATE_KEY_RECOVER:
            if (cmdLower === '/route') {
              this.state = State.PROBE_RECOVER;
            } else {
              this.apiKey = cmd;
              this.state = State.CALIBRATE_WAIT;
              setTimeout(() => {
                this.stopWait();
                this.state = State.PROBE_RECOVER;
                this.render();
              }, 3000);
            }
            break;

          case State.CALIBRATE_WAIT:
            this.state = State.PROBE_RECOVER;
            break;
        }
        this.render();
      }
    }

    const nexus = new Nexus();
    nexus.render();
  </script>
</body>
</html>
